"use client";

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  RefreshCw,
  Target,
  AlertCircle,
  Loader2,
  TrendingUp,
} from "lucide-react";
import Link from "next/link";
import CollapsibleSidebar from "@/components/CollapsibleSidebar";
import MobileNav from "@/components/MobileNav";
import FilterBar from "@/components/recommendations/FilterBar";
import ProjectCard from "@/components/recommendations/ProjectCard";
import PriorityCallout from "@/components/recommendations/PriorityCallout";
import type {
  ProjectRecommendation,
  FilterState,
  UserProject,
  ProjectProgress,
} from "@/types/recommendations";
import type { SkillGapAnalysis } from "@/types/skills";
import {
  applyFilters,
  sortRecommendations,
} from "@/lib/recommendations/filters";

interface RecommendationsResponse {
  recommendations: ProjectRecommendation[];
  skillGapAnalysis: SkillGapAnalysis;
  userProjects: UserProject[];
  cached: boolean;
  generatedAt: string;
}

export default function ProjectRecommendationsPage() {
  // State for recommendations data
  const [recommendations, setRecommendations] = useState<
    ProjectRecommendation[]
  >([]);
  const [skillGapAnalysis, setSkillGapAnalysis] =
    useState<SkillGapAnalysis | null>(null);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // State for filters
  const [filters, setFilters] = useState<FilterState>({
    difficulty: "all",
    category: "all",
    timeCommitment: "all",
    skills: [],
    sortBy: "priority",
    priorityLevel: "all",
  });

  // State for user projects
  const [savedProjects, setSavedProjects] = useState<Set<string>>(new Set());
  const [startedProjects, setStartedProjects] = useState<
    Map<string, ProjectProgress>
  >(new Map());

  // Fetch recommendations on mount
  useEffect(() => {
    fetchRecommendations();
  }, []);

  const fetchRecommendations = async (isRefresh = false) => {
    try {
      if (isRefresh) {
        setRefreshing(true);
      } else {
        setLoading(true);
      }
      setError(null);

      const response = await fetch("/api/recommendations");

      if (!response.ok) {
        if (response.status === 404) {
          const data = await response.json();
          setError(data.message || "No skill gap analysis found");
          return;
        }
        throw new Error("Failed to fetch recommendations");
      }

      const data: RecommendationsResponse = await response.json();

      setRecommendations(data.recommendations);
      setSkillGapAnalysis(data.skillGapAnalysis);

      // Process user projects
      const saved = new Set<string>();
      const started = new Map<string, ProjectProgress>();

      data.userProjects.forEach((project) => {
        if (project.status === "saved") {
          saved.add(project.projectId);
        } else if (
          project.status === "in_progress" ||
          project.status === "completed"
        ) {
          started.set(project.projectId, {
            projectId: project.projectId,
            status: project.status,
            progress: project.progress,
          });
        }
      });

      setSavedProjects(saved);
      setStartedProjects(started);
    } catch (err) {
      console.error("Error fetching recommendations:", err);
      setError(
        err instanceof Error ? err.message : "Failed to load recommendations"
      );
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    fetchRecommendations(true);
  };

  const handleFilterChange = (newFilters: FilterState) => {
    setFilters(newFilters);
  };

  const handleViewCritical = () => {
    // Apply filter to show only high-priority projects
    setFilters({
      difficulty: "all",
      category: "all",
      timeCommitment: "all",
      skills: [],
      sortBy: "priority",
      priorityLevel: "high",
    });
  };

  const handleSave = async (projectId: string) => {
    const isSaved = savedProjects.has(projectId);

    // Optimistic update
    const newSaved = new Set(savedProjects);
    if (isSaved) {
      newSaved.delete(projectId);
    } else {
      newSaved.add(projectId);
    }
    setSavedProjects(newSaved);

    try {
      if (isSaved) {
        // Find the user project ID to delete
        const response = await fetch("/api/user-projects");
        const data = await response.json();
        const userProject = data.userProjects.find(
          (p: { projectId: string }) => p.projectId === projectId
        );

        if (userProject) {
          // Delete via project_id lookup - we need to get the actual ID
          // For now, just call POST to toggle status
          await fetch("/api/user-projects", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ projectId, status: "saved" }),
          });
        }
      } else {
        await fetch("/api/user-projects", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ projectId, status: "saved" }),
        });
      }
    } catch (err) {
      console.error("Error saving project:", err);
      // Revert optimistic update
      setSavedProjects(savedProjects);
    }
  };

  const handleStart = async (projectId: string) => {
    const isStarted = startedProjects.has(projectId);

    // Optimistic update
    if (!isStarted) {
      const newStarted = new Map(startedProjects);
      newStarted.set(projectId, {
        projectId,
        status: "in_progress",
        progress: 0,
      });
      setStartedProjects(newStarted);

      // Remove from saved if it was saved
      if (savedProjects.has(projectId)) {
        const newSaved = new Set(savedProjects);
        newSaved.delete(projectId);
        setSavedProjects(newSaved);
      }
    }

    try {
      await fetch("/api/user-projects", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ projectId, status: "in_progress" }),
      });
    } catch (err) {
      console.error("Error starting project:", err);
      // Revert optimistic update
      setStartedProjects(startedProjects);
    }
  };

  const handleProgressUpdate = async (projectId: string, progress: number) => {
    // Optimistic update
    const current = startedProjects.get(projectId);
    if (current) {
      const newStarted = new Map(startedProjects);
      newStarted.set(projectId, {
        ...current,
        progress,
        status: progress === 100 ? "completed" : "in_progress",
      });
      setStartedProjects(newStarted);
    }

    try {
      // We need the actual user project ID - fetch it first
      const response = await fetch("/api/user-projects");
      const data = await response.json();
      const userProject = data.userProjects.find(
        (p: { projectId: string }) => p.projectId === projectId
      );

      if (userProject) {
        // Update progress - this endpoint needs the database ID
        // For now, we'll skip this as it requires the ID
        console.log("Progress update:", projectId, progress);
      }
    } catch (err) {
      console.error("Error updating progress:", err);
    }
  };

  // Apply filters and sorting
  const filteredRecommendations = sortRecommendations(
    applyFilters(recommendations, filters),
    filters.sortBy
  );

  // Calculate active filter count
  const activeFilterCount =
    (filters.difficulty !== "all" ? 1 : 0) +
    (filters.category !== "all" ? 1 : 0) +
    (filters.timeCommitment !== "all" ? 1 : 0) +
    (filters.priorityLevel && filters.priorityLevel !== "all" ? 1 : 0) +
    filters.skills.length;

  // Get available skills from recommendations
  const availableSkills = Array.from(
    new Set(recommendations.flatMap((r) => r.skillsTaught))
  ).sort();

  // Check if user has critical skill gaps
  const hasCriticalGaps =
    skillGapAnalysis?.missingSkills.essential.length ?? 0 > 0;

  // Loading state
  if (loading) {
    return (